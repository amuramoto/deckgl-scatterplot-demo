{"version":3,"sources":["../../../src/lib/attribute-manager.js"],"names":["LOG_START_END_PRIORITY","LOG_DETAIL_PRIORITY","noop","logFunctions","savedMessages","timeStart","onLog","level","message","log","onUpdateStart","numInstances","Date","onUpdate","push","onUpdateEnd","id","timeMs","Math","round","time","group","collapsed","groupEnd","AttributeManager","undefined","gl","stats","attributes","updateTriggers","accessors","needsRedraw","userData","attributeTransitionManager","AttributeTransitionManager","Object","seal","attributeName","delete","finalize","opts","clearRedrawFlags","redraw","updaters","_add","instanced","attributeNameArray","i","length","name","triggerName","invalidatedAttributes","_invalidateTrigger","setNeedsUpdate","data","transitions","props","buffers","context","updated","get","attribute","setExternalBuffer","setGenericValue","getAccessor","needsUpdate","_updateAttribute","shaderAttributes","shaderAttributeName","shaderAttribute","update","buffer","value","constant","timeEnd","timestamp","transitionUpdated","setCurrentTime","clearChangedFlags","changedAttributes","assign","getAttributes","changedShaderAttributes","hasAttribute","extraProps","warn","newAttributes","newAttribute","_createAttribute","_addShaderAttributes","_mapUpdateTriggersToAttributes","forceNoAlloc","isIndexed","elements","size","divisor","noAlloc","Attribute","triggers","getUpdateTriggers","forEach","keys","join","allocate","now","updateBuffer"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\nimport Attribute from './attribute';\nimport log from '../utils/log';\n\nimport AttributeTransitionManager from './attribute-transition-manager';\n\nconst LOG_START_END_PRIORITY = 2;\nconst LOG_DETAIL_PRIORITY = 3;\n\nfunction noop() {}\n\n// Default loggers\nconst logFunctions = {\n  savedMessages: null,\n  timeStart: null,\n  onLog: ({level, message}) => {\n    log.log(level, message)();\n  },\n  onUpdateStart: ({level, numInstances}) => {\n    logFunctions.savedMessages = [];\n    logFunctions.timeStart = new Date();\n  },\n  onUpdate: ({level, message}) => {\n    if (logFunctions.savedMessages) {\n      logFunctions.savedMessages.push(message);\n    }\n  },\n  onUpdateEnd: ({level, id, numInstances}) => {\n    const timeMs = Math.round(new Date() - logFunctions.timeStart);\n    const time = `${timeMs}ms`;\n    log.group(level, `Updated attributes for ${numInstances} instances in ${id} in ${time}`, {\n      collapsed: true\n    })();\n    for (const message of logFunctions.savedMessages) {\n      log.log(level, message)();\n    }\n    log.groupEnd(level, `Updated attributes for ${numInstances} instances in ${id} in ${time}`)();\n    logFunctions.savedMessages = null;\n  }\n};\n\nexport default class AttributeManager {\n  /**\n   * Sets log functions to help trace or time attribute updates.\n   * Default logging uses deck logger.\n   *\n   * `onLog` is called for each attribute.\n   *\n   * To enable detailed control of timming and e.g. hierarchical logging,\n   * hooks are also provided for update start and end.\n   *\n   * @param {Object} [opts]\n   * @param {String} [onLog=] - called to print\n   * @param {String} [onUpdateStart=] - called before update() starts\n   * @param {String} [onUpdateEnd=] - called after update() ends\n   */\n  static setDefaultLogFunctions({onLog, onUpdateStart, onUpdate, onUpdateEnd} = {}) {\n    if (onLog !== undefined) {\n      logFunctions.onLog = onLog || noop;\n    }\n    if (onUpdateStart !== undefined) {\n      logFunctions.onUpdateStart = onUpdateStart || noop;\n    }\n    if (onUpdate !== undefined) {\n      logFunctions.onUpdate = onUpdate || noop;\n    }\n    if (onUpdateEnd !== undefined) {\n      logFunctions.onUpdateEnd = onUpdateEnd || noop;\n    }\n  }\n\n  /**\n   * @classdesc\n   * Automated attribute generation and management. Suitable when a set of\n   * vertex shader attributes are generated by iteration over a data array,\n   * and updates to these attributes are needed either when the data itself\n   * changes, or when other data relevant to the calculations change.\n   *\n   * - First the application registers descriptions of its dynamic vertex\n   *   attributes using AttributeManager.add().\n   * - Then, when any change that affects attributes is detected by the\n   *   application, the app will call AttributeManager.invalidate().\n   * - Finally before it renders, it calls AttributeManager.update() to\n   *   ensure that attributes are automatically rebuilt if anything has been\n   *   invalidated.\n   *\n   * The application provided update functions describe how attributes\n   * should be updated from a data array and are expected to traverse\n   * that data array (or iterable) and fill in the attribute's typed array.\n   *\n   * Note that the attribute manager intentionally does not do advanced\n   * change detection, but instead makes it easy to build such detection\n   * by offering the ability to \"invalidate\" each attribute separately.\n   */\n  constructor(gl, {id = 'attribute-manager', stats} = {}) {\n    this.id = id;\n    this.gl = gl;\n\n    this.attributes = {};\n\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.needsRedraw = true;\n\n    this.userData = {};\n    this.stats = stats;\n\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: `${id}-transitions`\n    });\n\n    // For debugging sanity, prevent uninitialized members\n    Object.seal(this);\n  }\n\n  finalize() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].delete();\n    }\n    this.attributeTransitionManager.finalize();\n  }\n\n  // Returns the redraw flag, optionally clearing it.\n  // Redraw flag will be set if any attributes attributes changed since\n  // flag was last cleared.\n  //\n  // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n  // @return {false|String} - reason a redraw is needed.\n  getNeedsRedraw(opts = {clearRedrawFlags: false}) {\n    const redraw = this.needsRedraw;\n    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n    return redraw && this.id;\n  }\n\n  // Sets the redraw flag.\n  // @param {Boolean} redraw=true\n  // @return {AttributeManager} - for chaining\n  setNeedsRedraw(redraw = true) {\n    this.needsRedraw = true;\n    return this;\n  }\n\n  // Adds attributes\n  add(attributes, updaters) {\n    this._add(attributes, updaters);\n  }\n\n  // Adds attributes\n  addInstanced(attributes, updaters) {\n    this._add(attributes, updaters, {instanced: 1});\n  }\n\n  /**\n   * Removes attributes\n   * Takes an array of attribute names and delete them from\n   * the attribute map if they exists\n   *\n   * @example\n   * attributeManager.remove(['position']);\n   *\n   * @param {Object} attributeNameArray - attribute name array (see above)\n   */\n  remove(attributeNameArray) {\n    for (let i = 0; i < attributeNameArray.length; i++) {\n      const name = attributeNameArray[i];\n      if (this.attributes[name] !== undefined) {\n        this.attributes[name].delete();\n        delete this.attributes[name];\n      }\n    }\n  }\n\n  // Marks an attribute for update\n  invalidate(triggerName) {\n    const invalidatedAttributes = this._invalidateTrigger(triggerName);\n    // For performance tuning\n    logFunctions.onLog({\n      level: LOG_DETAIL_PRIORITY,\n      message: `invalidated attributes ${invalidatedAttributes} (${triggerName}) for ${this.id}`\n    });\n  }\n\n  invalidateAll() {\n    for (const attributeName in this.attributes) {\n      this.attributes[attributeName].setNeedsUpdate();\n    }\n    // For performance tuning\n    logFunctions.onLog({\n      level: LOG_DETAIL_PRIORITY,\n      message: `invalidated all attributes for ${this.id}`\n    });\n  }\n\n  // Ensure all attribute buffers are updated from props or data.\n  update({data, numInstances, transitions, props = {}, buffers = {}, context = {}} = {}) {\n    // keep track of whether some attributes are updated\n    let updated = false;\n\n    logFunctions.onUpdateStart({level: LOG_START_END_PRIORITY, id: this.id, numInstances});\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeStart();\n    }\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n\n      if (attribute.setExternalBuffer(buffers[attributeName], this.numInstances)) {\n        // Attribute is using external buffer from the props\n      } else if (attribute.setGenericValue(props[attribute.getAccessor()])) {\n        // Attribute is using generic value from the props\n      } else if (attribute.needsUpdate()) {\n        updated = true;\n        this._updateAttribute({attribute, numInstances, data, props, context});\n      }\n\n      if (attribute.userData.shaderAttributes) {\n        const shaderAttributes = attribute.userData.shaderAttributes;\n        for (const shaderAttributeName in shaderAttributes) {\n          const shaderAttribute = shaderAttributes[shaderAttributeName];\n          shaderAttribute.update({\n            buffer: attribute.buffer,\n            value: shaderAttribute.value || attribute.value,\n            constant: attribute.constant\n          });\n        }\n      }\n\n      this.needsRedraw |= attribute.needsRedraw();\n    }\n\n    if (updated) {\n      // Only initiate alloc/update (and logging) if actually needed\n      logFunctions.onUpdateEnd({level: LOG_START_END_PRIORITY, id: this.id, numInstances});\n    }\n\n    if (this.stats) {\n      this.stats.get('Update Attributes').timeEnd();\n    }\n\n    this.attributeTransitionManager.update({\n      attributes: this.attributes,\n      numInstances,\n      transitions\n    });\n  }\n\n  // Update attribute transition to the current timestamp\n  // Returns `true` if any transition is in progress\n  updateTransition(timestamp) {\n    const {attributeTransitionManager} = this;\n    const transitionUpdated = attributeTransitionManager.setCurrentTime(timestamp);\n    this.needsRedraw = this.needsRedraw || transitionUpdated;\n    return transitionUpdated;\n  }\n\n  /**\n   * Returns all attribute descriptors\n   * Note: Format matches luma.gl Model/Program.setAttributes()\n   * @return {Object} attributes - descriptors\n   */\n  getAttributes() {\n    return this.attributes;\n  }\n\n  /**\n   * Returns changed attribute descriptors\n   * This indicates which WebGLBuffers need to be updated\n   * @param opts.clearChangedFlags {Boolean}\n   * @return {Object} attributes - descriptors\n   */\n  getChangedAttributes(opts = {clearChangedFlags: false}) {\n    const {attributes, attributeTransitionManager} = this;\n\n    const changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());\n    const changedShaderAttributes = {};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n        changedAttributes[attributeName] = attribute;\n      }\n    }\n\n    for (const attributeName in changedAttributes) {\n      const attribute = changedAttributes[attributeName];\n\n      if (attribute.userData.shaderAttributes) {\n        const shaderAttributes = attribute.userData.shaderAttributes;\n        for (const shaderAttributeName in shaderAttributes) {\n          changedShaderAttributes[shaderAttributeName] = shaderAttributes[shaderAttributeName];\n        }\n      } else {\n        changedShaderAttributes[attributeName] = attribute;\n      }\n    }\n\n    return changedShaderAttributes;\n  }\n\n  // PROTECTED METHODS - Only to be used by collaborating classes, not by apps\n\n  // Returns object containing all accessors as keys, with non-null values\n  // @return {Object} - accessors object\n  getAccessors() {\n    return this.updateTriggers;\n  }\n\n  // PRIVATE METHODS\n\n  // Used to register an attribute\n  _add(attributes, updaters, extraProps = {}) {\n    if (updaters) {\n      log.warn('AttributeManager.add({updaters}) - updater map no longer supported')();\n    }\n\n    const newAttributes = {};\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      const newAttribute = this._createAttribute(attributeName, attribute, extraProps);\n\n      if (attribute.shaderAttributes) {\n        this._addShaderAttributes(newAttribute, attribute.shaderAttributes, extraProps);\n      }\n\n      newAttributes[attributeName] = newAttribute;\n    }\n\n    Object.assign(this.attributes, newAttributes);\n\n    this._mapUpdateTriggersToAttributes();\n  }\n  /* eslint-enable max-statements */\n\n  _addShaderAttributes(attribute, shaderAttributes, extraProps) {\n    attribute.userData.shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributes) {\n      const shaderAttribute = shaderAttributes[shaderAttributeName];\n\n      // Initialize the attribute descriptor, with WebGL and metadata fields\n      attribute.userData.shaderAttributes[shaderAttributeName] = this._createAttribute(\n        shaderAttributeName,\n        shaderAttribute,\n        extraProps,\n        true\n      );\n    }\n  }\n\n  _createAttribute(name, attribute, extraProps, forceNoAlloc = false) {\n    const props = {\n      id: name,\n      // Luma fields\n      constant: attribute.constant || false,\n      isIndexed: attribute.isIndexed || attribute.elements,\n      size: (attribute.elements && 1) || attribute.size,\n      value: attribute.value || null,\n      divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor\n    };\n\n    if (forceNoAlloc) {\n      props.noAlloc = true;\n    }\n\n    return new Attribute(this.gl, Object.assign({}, attribute, props));\n  }\n\n  // build updateTrigger name to attribute name mapping\n  _mapUpdateTriggersToAttributes() {\n    const triggers = {};\n\n    for (const attributeName in this.attributes) {\n      const attribute = this.attributes[attributeName];\n      attribute.getUpdateTriggers().forEach(triggerName => {\n        if (!triggers[triggerName]) {\n          triggers[triggerName] = [];\n        }\n        triggers[triggerName].push(attributeName);\n      });\n    }\n\n    this.updateTriggers = triggers;\n  }\n\n  _invalidateTrigger(triggerName) {\n    const {attributes, updateTriggers} = this;\n    const invalidatedAttributes = updateTriggers[triggerName];\n\n    if (invalidatedAttributes) {\n      invalidatedAttributes.forEach(name => {\n        const attribute = attributes[name];\n        if (attribute) {\n          attribute.setNeedsUpdate();\n        }\n      });\n    } else {\n      let message = `invalidating non-existent trigger ${triggerName} for ${this.id}\\n`;\n      message += `Valid triggers: ${Object.keys(attributes).join(', ')}`;\n      log.warn(message, invalidatedAttributes)();\n    }\n    return invalidatedAttributes;\n  }\n\n  _updateAttribute({attribute, numInstances, data, props, context}) {\n    if (attribute.allocate(numInstances)) {\n      logFunctions.onUpdate({\n        level: LOG_DETAIL_PRIORITY,\n        message: `${attribute.id} allocated ${numInstances}`,\n        id: this.id\n      });\n    }\n\n    // Calls update on any buffers that need update\n    const timeStart = Date.now();\n\n    const updated = attribute.updateBuffer({numInstances, data, props, context});\n    if (updated) {\n      this.needsRedraw = true;\n\n      const timeMs = Math.round(Date.now() - timeStart);\n      logFunctions.onUpdate({\n        level: LOG_DETAIL_PRIORITY,\n        message: `${attribute.id} updated ${numInstances} in ${timeMs}ms`\n      });\n    }\n  }\n}\n"],"file":"attribute-manager.js"}
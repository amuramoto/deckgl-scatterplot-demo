{"version":3,"sources":["../../../../src/lib/loader-utils/auto-detect-loader.js"],"names":["EXT_PATTERN","autoDetectLoader","data","loaders","url","loader","findLoaderByUrl","findLoaderByExamingInitialData","match","extension","findLoaderByExtension","toLowerCase","extensions","loaderExtension","testText","ArrayBuffer","testBinary","type","Array","isArray","test","byteOffset","tests","some","magic","getMagicString","length","arrayBuffer","byteLength","dataView","DataView","i","String","fromCharCode","getUint8"],"mappings":"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","sourcesContent":["import {normalizeLoader} from './normalize-loader';\n\nconst EXT_PATTERN = /[^.]+$/;\n\n// Find a loader that works for extension/text\n// Search the loaders array argument for a loader that matches extension or text\nexport function autoDetectLoader(data, loaders, {url = ''} = {}) {\n  let loader = null;\n  loader = loader || findLoaderByUrl(loaders, url);\n  loader = loader || findLoaderByExamingInitialData(loaders, data);\n  return loader;\n}\n\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders, url) {\n  // Get extension\n  const match = url.match(EXT_PATTERN);\n  const extension = match && match[0];\n  const loader = extension && findLoaderByExtension(loaders, extension);\n  return loader;\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByExamingInitialData(loaders, data) {\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testText(data, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      if (testBinary(data, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\n\nfunction testText(data, loader) {\n  return loader.testText && loader.testText(data);\n}\n\nfunction testBinary(data, loader) {\n  const type = Array.isArray(loader.test) ? 'array' : typeof loader.test;\n  switch (type) {\n    case 'function':\n      return loader.test(data, loader);\n\n    case 'string':\n    case 'array':\n      // Magic bytes check: If `loader.test` is a string or array of strings,\n      // check if binary data starts with one of those strings\n      const byteOffset = 0;\n      const tests = Array.isArray(loader.test) ? loader.test : [loader.test];\n\n      return tests.some(test => {\n        const magic = getMagicString(data, byteOffset, test.length);\n        return test === magic;\n      });\n\n    default:\n      return false;\n  }\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n"],"file":"auto-detect-loader.js"}